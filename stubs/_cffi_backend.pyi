import types
from _typeshed import Incomplete
from typing import Any, ClassVar, overload

ffi: Incomplete

FFI_CDECL: int
FFI_DEFAULT_ABI: int
RTLD_GLOBAL: int
RTLD_LAZY: int
RTLD_LOCAL: int
RTLD_NODELETE: int
RTLD_NOLOAD: int
RTLD_NOW: int
__version__: str

class CField:
    bitshift: Incomplete
    bitsize: Incomplete
    flags: Incomplete
    offset: Incomplete
    type: Incomplete

class CLibrary:
    def close_lib(self, *args, **kwargs): ...
    def load_function(self, *args, **kwargs): ...
    def read_variable(self, *args, **kwargs): ...
    def write_variable(self, *args, **kwargs): ...

class CType:
    abi: Incomplete
    args: Incomplete
    cname: Incomplete
    elements: Incomplete
    ellipsis: Incomplete
    fields: Incomplete
    item: Incomplete
    kind: Incomplete
    length: Incomplete
    relements: Incomplete
    result: Incomplete
    def __dir__(self): ...

class FFI:
    class CData:
        def __add__(self, other): ...
        def __bool__(self) -> bool: ...
        def __call__(self, *args, **kwargs): ...
        def __complex__(self) -> complex: ...
        def __delattr__(self, name): ...
        def __delitem__(self, other) -> None: ...
        def __dir__(self): ...
        def __enter__(self): ...
        def __eq__(self, other: object) -> bool: ...
        def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...
        def __float__(self) -> float: ...
        def __ge__(self, other: object) -> bool: ...
        def __getitem__(self, index): ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __int__(self) -> int: ...
        def __iter__(self): ...
        def __le__(self, other: object) -> bool: ...
        def __len__(self) -> int: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __radd__(self, other): ...
        def __rsub__(self, other): ...
        def __setattr__(self, name, value): ...
        def __setitem__(self, index, object) -> None: ...
        def __sub__(self, other): ...

    class CType:
        abi: Incomplete
        args: Incomplete
        cname: Incomplete
        elements: Incomplete
        ellipsis: Incomplete
        fields: Incomplete
        item: Incomplete
        kind: Incomplete
        length: Incomplete
        relements: Incomplete
        result: Incomplete
        def __dir__(self): ...

    class buffer:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __delitem__(self, other) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getitem__(self, index): ...
        def __gt__(self, other: object) -> bool: ...
        def __le__(self, other: object) -> bool: ...
        def __len__(self) -> int: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setitem__(self, index, object) -> None: ...
    NULL: ClassVar[_CDataBase] = ...
    RTLD_GLOBAL: ClassVar[int] = ...
    RTLD_LAZY: ClassVar[int] = ...
    RTLD_LOCAL: ClassVar[int] = ...
    RTLD_NODELETE: ClassVar[int] = ...
    RTLD_NOLOAD: ClassVar[int] = ...
    RTLD_NOW: ClassVar[int] = ...
    error: ClassVar[type[ffi.error]] = ...
    errno: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def addressof(self, *args, **kwargs): ...
    def alignof(self, *args, **kwargs): ...
    def callback(self, *args, **kwargs): ...
    def cast(self, *args, **kwargs): ...
    def def_extern(self, *args, **kwargs): ...
    def dlclose(self, *args, **kwargs): ...
    def dlopen(self, *args, **kwargs): ...
    def from_buffer(self, *args, **kwargs): ...
    def from_handle(self, *args, **kwargs): ...
    def gc(self, *args, **kwargs): ...
    def getctype(self, *args, **kwargs): ...
    @overload
    def init_once(self, function, tag) -> Any: ...
    @overload
    def init_once(self) -> Any: ...
    def integer_const(self, *args, **kwargs): ...
    def list_types(self, *args, **kwargs): ...
    @overload
    def memmove(self, dest, src, n) -> Any: ...
    @overload
    def memmove(self) -> Any: ...
    def new(self, *args, **kwargs): ...
    def new_allocator(self, *args, **kwargs): ...
    def new_handle(self) -> Any: ...
    def offsetof(self, *args, **kwargs): ...
    def release(self, *args, **kwargs): ...
    def sizeof(self, *args, **kwargs): ...
    def string(self, orunicodestring) -> Any: ...
    def typeof(self, *args, **kwargs): ...
    def unpack(self, *args, **kwargs): ...

class Lib:
    def __delattr__(self, name): ...
    def __dir__(self): ...
    def __setattr__(self, name, value): ...

class _CDataBase:
    def __add__(self, other): ...
    def __bool__(self) -> bool: ...
    def __call__(self, *args, **kwargs): ...
    def __complex__(self) -> complex: ...
    def __delattr__(self, name): ...
    def __delitem__(self, other) -> None: ...
    def __dir__(self): ...
    def __enter__(self): ...
    def __eq__(self, other: object) -> bool: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...
    def __float__(self) -> float: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def __iter__(self): ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other): ...
    def __rsub__(self, other): ...
    def __setattr__(self, name, value): ...
    def __setitem__(self, index, object) -> None: ...
    def __sub__(self, other): ...

class __CDataFromBuf(_CDataBase): ...

class __CDataGCP(_CDataBase):
    def __del__(self, *args, **kwargs) -> None: ...

class __CDataOwn(_CDataBase):
    def __delitem__(self, other) -> None: ...
    def __getitem__(self, index): ...
    def __len__(self) -> int: ...
    def __setitem__(self, index, object) -> None: ...

class __CDataOwnGC(__CDataOwn): ...

class __CData_iterator:
    def __iter__(self): ...
    def __next__(self): ...

class __FFIGlobSupport: ...

class buffer:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __delitem__(self, other) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setitem__(self, index, object) -> None: ...

def alignof(*args, **kwargs): ...
def callback(*args, **kwargs): ...
def cast(*args, **kwargs): ...
def complete_struct_or_union(*args, **kwargs): ...
def from_buffer(*args, **kwargs): ...
def from_handle(*args, **kwargs): ...
def gcp(*args, **kwargs): ...
def get_errno(*args, **kwargs): ...
def getcname(*args, **kwargs): ...
def load_library(*args, **kwargs): ...
def memmove(*args, **kwargs): ...
def new_array_type(*args, **kwargs): ...
def new_enum_type(*args, **kwargs): ...
def new_function_type(*args, **kwargs): ...
def new_pointer_type(*args, **kwargs): ...
def new_primitive_type(*args, **kwargs): ...
def new_struct_type(*args, **kwargs): ...
def new_union_type(*args, **kwargs): ...
def new_void_type(*args, **kwargs): ...
def newp(*args, **kwargs): ...
def newp_handle(*args, **kwargs): ...
def rawaddressof(*args, **kwargs): ...
def release(*args, **kwargs): ...
def set_errno(*args, **kwargs): ...
def sizeof(*args, **kwargs): ...
def string(*args, **kwargs): ...
def typeof(*args, **kwargs): ...
def typeoffsetof(*args, **kwargs): ...
def unpack(*args, **kwargs): ...
